
extern "C"{	
	#include "cfsqpusr.h"	
}

# include "MyNNet.h"

//#include <time.h>
# include <stdio.h>
#include <iostream>
# include <math.h>
using namespace std;

double NumeroRand(double max);
double TrovaMinimo(double *Array, int MaxDim);
double TrovaMassimo(double *Array, int MaxDim);
double modulo(double num);

void AddestraNN_funzioneconCFSQP();
void Addestra_InseguiFunzione();
double Funzione_InseguiFunzione(double x);
double EseguiTest_InseguiFunzione(double *x, bool stampa=false);

void obj32(int nparam, int j, double *a_csfqp,double *fj, void *cd);
void cntr32(int nparam,int j,double *a_csfqp,double *gj,void *cd);

void Liapunov1();
void obj32_bis(int nparam, int j, double *a_csfqp,double *fj, void *cd);
void cntr32_bis(int nparam,int j,double *a_csfqp,double *gj,void *cd);

int campionifunzione=(int)19;		
ReteNeurale *NN_funzione;
double pigreco_inc=(3.141592654)/4.0;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

double a=0.5, b=1.0, gamma=1.0;
const int numc=21;
double c[numc];
double f1(double *X); double f2(double *X); double f3(double *X); double f4(double *X);
int ApplyRules(float X0, float X1); int ApplyRules_LLMzero(float X0, float X1); int ApplyRules_DT(float X0, float X1);
int ApplyRules_LLMzero_meno(float X0, float X1); int ApplyRules_sogliaVR(float X0, float X1);
void ROA_bruteforce();
int Srotola(double x0, double x1);

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
void main(){	

	srand(time(NULL));

	//---------------------------
	unsigned int durata = 0;
	unsigned int durata_sec = 0;
	unsigned int durata_min = 0;
	unsigned int durata_ore = 0;
	clock_t inizio, fine;
	//---------------------------		

	//---------------------------
	inizio = clock();
	//cout<<endl<<endl<<"INIZIO ADDESTRAMENTO"<<endl;
	//---------------------------

	//Liapunov1();

	ROA_bruteforce();
	return;

	//---------------------------
	//ROI senza Liapunov

	// slide 12 roa Lect_11.pdf
	FILE *Output2; Output2=fopen("LogMetrics.txt","w"); fclose(Output2);
	Output2=fopen("LogMetrics.txt","w"); fprintf(Output2,"X0\tX1\tclasse\tX0T\tX1T"); fprintf(Output2,"\n"); fclose(Output2);

	double stepsize=0.01, tempo, DurataSrotola=10000; bool exit, uscitoROI, stable;
	double *X; int i, classe, j, puntigriglia=1e5*4; 
	X=(double *)calloc(2,sizeof(double));	

	for(j=0;j<puntigriglia;j++){

		uscitoROI=false; stable=false;
		for(i=0;i<2;i++) X[i]=-4+NumeroRand(8);
		//printf("\n\n******\n%.3f\t%.3f\t%.3f\t%.3f",X[0],X[1],X[2],X[3]); //system("pause");
		
		// Solo se sono dentro la prevista ROI genero le traiettorie a partire dall'X(0) estratto
		if( ApplyRules(X[0], X[1])==0 ){
		//if( 1 ){
			
			Output2=fopen("LogMetrics.txt","a"); 
			fprintf(Output2,"%.3f\t%.3f",X[0],X[1]); 
			fclose(Output2);
			
			tempo=0; exit=false;
			while( tempo<=DurataSrotola && !exit){

				tempo+=stepsize;
				X[0]=X[0] + stepsize*f1(X); X[1]=X[1] + stepsize*f2(X); 
				if(modulo(X[0])>1e4 || modulo(X[1])>1e4 || modulo(X[2])>1e4 || modulo(X[3])>1e4) 
					exit=true;
				// Controllo se sono uscito dalla ROI ad ogni avanzamento del sistema dinamico
				if( 1 && ApplyRules(X[0], X[1])!=0 ){
					uscitoROI=true; /*exit=true;*/
				}
				 				
			}//END while(clock<=DurataSrotola)			

		  if(X[0]<0.1 && X[1]<0.1) stable=true;
		  if(stable && !uscitoROI) classe=0;
		  if(!stable) classe=1;
		  if(stable && uscitoROI) classe=2;
			
			//printf("\n\nclasse=%d\n\n",classe);

			Output2=fopen("LogMetrics.txt","a"); 
			fprintf(Output2,"\t%d",classe); 
			fprintf(Output2,"\t%.2e\t%.2e",X[0],X[1]); 
			fprintf(Output2,"\n");	fclose(Output2);

		}

	}// END ciclo puntigriglia

	free(X);
	//END ROI senza Liapunov
	//---------------------------

	//---------------------------
	fine = clock();
	cout<<endl<<"FINE"<<endl<<endl;
	durata = (unsigned int) (fine-inizio)/CLOCKS_PER_SEC;

	durata_ore = durata / 3600;
	durata_min = (durata % 3600)/60;
	durata_sec = (durata % 3600)%60;
	cout<<"DURATA: "<<durata_ore<<" ore\t"<<durata_min<<" minuti\t"<<durata_sec<<" secondi"<<endl<<endl;
	//---------------------------
	
	system("pause");
	return;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	int neuronistrtonascosto=35;
	NN_funzione = new ReteNeurale(1,neuronistrtonascosto,1);

	printf("\n\n ----- AddestraNN_funzioneconCFSQP -----");
	AddestraNN_funzioneconCFSQP();	
	
	printf("\n\n"); system("pause");
	
	printf("\n\n ----- Addestra_InseguiFunzione con BB -----");	
	NN_funzione->Inizializza(1,neuronistrtonascosto,1,false);
	Addestra_InseguiFunzione();
	EseguiTest_InseguiFunzione(NULL);
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
}//fine main
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
int ApplyRules_DT(float X0, float X1) {
  
	if ( ((X0 > -1.305000 && X0 <= 1.522000) && (X1 > -0.873000 && X1 <= 0.980000)) ||
   ((X0 > -1.745000 && X0 <= 0.578000) && (X1 > -1.615000 && X1 <= -0.873000)) ||
   ((X0 > -0.589000 && X0 <= 1.744000) && (X1 > 0.980000 && X1 <= 1.598000)) ||
   ((X0 > -1.537000 && X0 <= 0.101000) && (X1 > -2.151000 && X1 <= -1.615000)) ||
   ((X0 > -0.141000 && X0 <= 1.574000) && (X1 > 1.598000 && X1 <= 2.031000)) ||
   ((X0 > 1.522000 && X0 <= 1.929000) && (X1 > -0.476000 && X1 <= 0.980000)) ||
   ((X0 > -1.919000 && X0 <= -1.513000) && (X1 > -0.873000 && X1 <= 0.536000)) ||
   ((X0 > -1.313000 && X0 <= -0.323000) && (X1 > -2.486000 && X1 <= -2.151000)) ||
   ((X0 > 0.330000 && X0 <= 1.405000) && (X1 > 2.031000 && X1 <= 2.352000)) ||
   ((X0 > -1.513000 && X0 <= -1.305000) && (X1 > -0.873000 && X1 <= 0.844000)) ||
   ((X0 > 0.488000 && X0 <= 1.223000) && (X1 > 2.352000 && X1 <= 2.622000)) ||
   ((X0 > 0.578000 && X0 <= 0.804000) && (X1 > -1.394000 && X1 <= -0.873000)) ||
   ((X0 > -1.121000 && X0 <= -0.512000) && (X1 > -2.653000 && X1 <= -2.486000)) ||
   ((X0 > -0.695000 && X0 <= -0.589000) && (X1 > 0.980000 && X1 <= 1.515000)) ||
   ((X0 > -0.005000 && X0 <= 0.330000) && (X1 > 2.031000 && X1 <= 2.263000)) ||
   ((X0 > 0.804000 && X0 <= 1.182000) && (X1 > -1.094000 && X1 <= -0.873000)) ||
   ((X0 > -1.179000 && X0 <= -0.695000) && (X1 > 0.980000 && X1 <= 1.102000)) ||
   ((X0 > 0.101000 && X0 <= 0.259000) && (X1 > -2.048000 && X1 <= -1.615000)) ||
   ((X0 > -1.981000 && X0 <= -1.919000) && (X1 > -0.646000 && X1 <= 0.272000)) ||
   ((X0 > 1.522000 && X0 <= 1.720000) && (X1 > -0.664000 && X1 <= -0.476000)) ||
   ((X0 > -0.301000 && X0 <= -0.141000) && (X1 > 1.598000 && X1 <= 1.869000)) ||
   ((X0 > -1.637000 && X0 <= -1.513000) && (X1 > 0.536000 && X1 <= 0.746000)) ||
   ((X0 > -1.782000 && X0 <= -1.745000) && (X1 > -1.443000 && X1 <= -0.873000)) ||
   ((X0 > 1.929000 && X0 <= 1.971000) && (X1 > -0.372000 && X1 <= 0.583000)) ||
   ((X0 > -0.323000 && X0 <= -0.139000) && (X1 > -2.360000 && X1 <= -2.151000)) ||
   ((X0 > -0.926000 && X0 <= -0.695000) && (X1 > 1.102000 && X1 <= 1.301000)) ||
   ((X0 > -1.622000 && X0 <= -1.537000) && (X1 > -1.927000 && X1 <= -1.615000)) ||
   ((X0 > -1.842000 && X0 <= -1.782000) && (X1 > -1.226000 && X1 <= -0.873000)) ||
   ((X0 > 1.574000 && X0 <= 1.672000) && (X1 > 1.598000 && X1 <= 1.809000)) ||
   ((X0 > 0.804000 && X0 <= 0.962000) && (X1 > -1.239000 && X1 <= -1.094000)) ||
   ((X0 > -0.457000 && X0 <= -0.301000) && (X1 > 1.598000 && X1 <= 1.755000)) ||
   ((X0 > 1.720000 && X0 <= 1.856000) && (X1 > -0.610000 && X1 <= -0.476000)) ||
   ((X0 > 1.744000 && X0 <= 1.837000) && (X1 > 0.980000 && X1 <= 1.204000)) ||
   ((X0 > 0.631000 && X0 <= 1.008000) && (X1 > 2.622000 && X1 <= 2.663000)) ||
   ((X0 > 0.330000 && X0 <= 0.488000) && (X1 > 2.352000 && X1 <= 2.485000)) ||
   ((X0 > 1.971000 && X0 <= 1.999000) && (X1 > -0.337000 && X1 <= 0.428000)) ||
   ((X0 > -2.011000 && X0 <= -1.981000) && (X1 > -0.406000 && X1 <= 0.125000)) ||
   ((X0 > 0.259000 && X0 <= 0.345000) && (X1 > -1.823000 && X1 <= -1.615000)) ||
   ((X0 > 0.178000 && X0 <= 0.330000) && (X1 > 2.263000 && X1 <= 2.377000)) ||
   ((X0 > -0.512000 && X0 <= -0.405000) && (X1 > -2.558000 && X1 <= -2.486000)) ||
   ((X0 > 0.578000 && X0 <= 0.677000) && (X1 > -1.541000 && X1 <= -1.394000)) ||
   ((X0 > 1.182000 && X0 <= 1.242000) && (X1 > -0.972000 && X1 <= -0.873000)) ||
   ((X0 > -0.823000 && X0 <= -0.695000) && (X1 > 1.301000 && X1 <= 1.364000)) ||
   ((X0 > -0.229000 && X0 <= -0.141000) && (X1 > 1.869000 && X1 <= 1.964000)) ||
   ((X0 > 1.744000 && X0 <= 1.814000) && (X1 > 1.204000 && X1 <= 1.457000)) ||
   ((X0 > -1.391000 && X0 <= -1.313000) && (X1 > -2.341000 && X1 <= -2.151000)) ||
   ((X0 > -0.139000 && X0 <= -0.022000) && (X1 > -2.232000 && X1 <= -2.151000)) ||
   ((X0 > -0.098000 && X0 <= -0.005000) && (X1 > 2.031000 && X1 <= 2.108000)) ||
   ((X0 > 1.405000 && X0 <= 1.485000) && (X1 > 2.031000 && X1 <= 2.194000)) ||
   ((X0 > -1.672000 && X0 <= -1.622000) && (X1 > -1.859000 && X1 <= -1.615000)) ||
   ((X0 > 0.414000 && X0 <= 0.488000) && (X1 > 2.485000 && X1 <= 2.537000)) ||
   ((X0 > -1.464000 && X0 <= -1.391000) && (X1 > -2.234000 && X1 <= -2.151000)) ||
   ((X0 > -1.929000 && X0 <= -1.842000) && (X1 > -0.936000 && X1 <= -0.873000)) ||
   ((X0 > 1.522000 && X0 <= 1.664000) && (X1 > -0.715000 && X1 <= -0.664000)) ||
   ((X0 > -0.343000 && X0 <= -0.301000) && (X1 > 1.755000 && X1 <= 1.840000)) ||
   ((X0 > -1.279000 && X0 <= -1.121000) && (X1 > -2.571000 && X1 <= -2.486000)) ||
   ((X0 > -0.139000 && X0 <= -0.076000) && (X1 > -2.302000 && X1 <= -2.232000)) ||
   ((X0 > 0.345000 && X0 <= 0.458000) && (X1 > -1.693000 && X1 <= -1.615000)) ||
   ((X0 > 0.804000 && X0 <= 0.854000) && (X1 > -1.316000 && X1 <= -1.239000)) ||
   ((X0 > -1.947000 && X0 <= -1.919000) && (X1 > -0.810000 && X1 <= -0.646000)) ||
   ((X0 > -1.975000 && X0 <= -1.919000) && (X1 > 0.272000 && X1 <= 0.322000)) ||
   ((X0 > -1.736000 && X0 <= -1.637000) && (X1 > 0.536000 && X1 <= 0.664000)) ||
   ((X0 > 0.225000 && X0 <= 0.330000) && (X1 > 2.377000 && X1 <= 2.433000)) ||
   ((X0 > -1.831000 && X0 <= -1.782000) && (X1 > -1.288000 && X1 <= -1.226000)) ||
   ((X0 > 0.962000 && X0 <= 0.988000) && (X1 > -1.195000 && X1 <= -1.094000)) ||
   ((X0 > -1.792000 && X0 <= -1.736000) && (X1 > 0.536000 && X1 <= 0.619000)) ||
   ((X0 > 1.672000 && X0 <= 1.744000) && (X1 > 1.598000 && X1 <= 1.611000)) ) return 0;

  return 1;
}
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
int ApplyRules_sogliaVR(float X0, float X1) {

	   if ( ((X0 > -0.516500 && X0 <= 1.142500) && (X1 > -0.823500 && X1 <= 1.483500)) ||
   ((X0 > -0.422500 && X0 <= 1.434500) && (X1 > -0.453500 && X1 <= 1.599500)) ||
   ((X0 > -0.280500 && X0 <= 1.325500) && (X1 > -0.630500 && X1 <= 1.755500)) ||
   ((X0 > -0.422500 && X0 <= 1.338500) && (X1 > -0.556500 && X1 <= 1.599500)) ||
   ((X0 > -1.374500 && X0 <= 0.628500) && (X1 > -1.386500 && X1 <= 0.530500)) ||
   ((X0 > -0.369500 && X0 <= 1.406500) && (X1 > -0.472500 && X1 <= 1.662500)) ||
   ((X0 > -0.393500 && X0 <= 1.434500) && (X1 > -0.453500 && X1 <= 1.611500)) ||
   ((X0 > -0.727500 && X0 <= 1.330500) && (X1 > -0.580500 && X1 <= 1.249500)) ||
   ((X0 > -1.350500 && X0 <= 0.273500) && (X1 > -1.764500 && X1 <= 0.563500)) ||
   ((X0 > -1.436500 && X0 <= 0.439500) && (X1 > -1.588500 && X1 <= 0.415500)) ||
   ((X0 > -1.394500 && X0 <= 0.364500) && (X1 > -1.644500 && X1 <= 0.501500)) ||
   ((X0 > -1.374500 && X0 <= 0.307500) && (X1 > -1.707500 && X1 <= 0.530500)) ||
   ((X0 > -0.219500 && X0 <= 1.291500) && (X1 > -0.643500 && X1 <= 1.831500)) ||
   ((X0 > -0.312500 && X0 <= 1.374500) && (X1 > -0.513500 && X1 <= 1.712500)) ||
   ((X0 > -1.391500 && X0 <= 0.325500) && (X1 > -1.687500 && X1 <= 0.501500)) ||
   ((X0 > -0.219500 && X0 <= 1.314500) && (X1 > -0.630500 && X1 <= 1.803500)) ||
   ((X0 > -0.284500 && X0 <= 1.353500) && (X1 > -0.549500 && X1 <= 1.726500)) ||
   ((X0 > -1.209500 && X0 <= 0.251500) && (X1 > -1.777500 && X1 <= 0.772500)) ||
   ((X0 > -1.405500 && X0 <= 0.383500) && (X1 > -1.631500 && X1 <= 0.446500)) ||
   ((X0 > -1.308500 && X0 <= 0.210500) && (X1 > -1.806500 && X1 <= 0.614500)) ||
   ((X0 > -0.682500 && X0 <= 1.441500) && (X1 > -0.382500 && X1 <= 1.328500)) ||
   ((X0 > -0.459500 && X0 <= 1.453500) && (X1 > -0.348500 && X1 <= 1.559500)) ||
   ((X0 > -1.280500 && X0 <= 0.197500) && (X1 > -1.830500 && X1 <= 0.649500)) ||
   ((X0 > -0.164500 && X0 <= 1.270500) && (X1 > -0.697500 && X1 <= 1.848500)) ||
   ((X0 > -0.312500 && X0 <= 1.118500) && (X1 > -0.840500 && X1 <= 1.712500)) ||
   ((X0 > -0.495500 && X0 <= 1.456500) && (X1 > -0.348500 && X1 <= 1.501500)) ||
   ((X0 > -1.263500 && X0 <= 0.170500) && (X1 > -1.850500 && X1 <= 0.686500)) ||
   ((X0 > -1.456500 && X0 <= 0.457500) && (X1 > -1.539500 && X1 <= 0.353500)) ||
   ((X0 > -0.136500 && X0 <= 1.234500) && (X1 > -0.724500 && X1 <= 1.897500)) ||
   ((X0 > -0.526500 && X0 <= 1.497500) && (X1 > -0.291500 && X1 <= 1.470500)) ||
   ((X0 > -0.564500 && X0 <= 1.497500) && (X1 > -0.291500 && X1 <= 1.440500)) ||
   ((X0 > -1.472500 && X0 <= 0.525500) && (X1 > -1.485500 && X1 <= 0.312500)) ||
   ((X0 > -1.465500 && X0 <= 0.468500) && (X1 > -1.535500 && X1 <= 0.317500)) ||
   ((X0 > -1.472500 && X0 <= 0.486500) && (X1 > -1.504500 && X1 <= 0.312500)) ||
   ((X0 > -1.487500 && X0 <= 0.553500) && (X1 > -1.449500 && X1 <= 0.271500)) ||
   ((X0 > -1.244500 && X0 <= 0.113500) && (X1 > -1.886500 && X1 <= 0.710500)) ||
   ((X0 > -0.082500 && X0 <= 1.219500) && (X1 > -0.741500 && X1 <= 1.908500)) ||
   ((X0 > -0.600500 && X0 <= 1.515500) && (X1 > -0.218500 && X1 <= 1.398500)) ||
   ((X0 > -1.516500 && X0 <= 0.587500) && (X1 > -1.416500 && X1 <= 0.207500)) ||
   ((X0 > -1.495500 && X0 <= 0.684500) && (X1 > -1.318500 && X1 <= 0.255500)) ||
   ((X0 > -1.209500 && X0 <= 0.058500) && (X1 > -1.921500 && X1 <= 0.772500)) ||
   ((X0 > -0.018500 && X0 <= 1.194500) && (X1 > -0.793500 && X1 <= 1.937500)) ||
   ((X0 > -1.542500 && X0 <= 0.628500) && (X1 > -1.367500 && X1 <= 0.138500)) ||
   ((X0 > -0.637500 && X0 <= 1.545500) && (X1 > -0.131500 && X1 <= 1.348500)) ||
   ((X0 > -1.548500 && X0 <= 0.681500) && (X1 > -1.330500 && X1 <= 0.129500)) ||
   ((X0 > -1.171500 && X0 <= -0.000500) && (X1 > -1.962500 && X1 <= 0.789500)) ||
   ((X0 > 0.018500 && X0 <= 1.165500) && (X1 > -0.796500 && X1 <= 1.964500)) ||
   ((X0 > -1.548500 && X0 <= 0.734500) && (X1 > -1.262500 && X1 <= 0.129500)) ||
   ((X0 > -0.699500 && X0 <= 1.567500) && (X1 > -0.084500 && X1 <= 1.297500)) ||
   ((X0 > -0.687500 && X0 <= 1.559500) && (X1 > -0.087500 && X1 <= 1.302500)) ||
   ((X0 > 0.057500 && X0 <= 1.142500) && (X1 > -0.822500 && X1 <= 1.978500)) ||
   ((X0 > -1.566500 && X0 <= 0.702500) && (X1 > -1.287500 && X1 <= 0.070500)) ||
   ((X0 > -1.131500 && X0 <= -0.081500) && (X1 > -1.990500 && X1 <= 0.835500)) ||
   ((X0 > -0.727500 && X0 <= 1.587500) && (X1 > -0.012500 && X1 <= 1.249500)) ||
   ((X0 > -0.756500 && X0 <= 1.587500) && (X1 > -0.012500 && X1 <= 1.235500)) ||
   ((X0 > 0.110500 && X0 <= 1.142500) && (X1 > -0.822500 && X1 <= 1.999500)) ||
   ((X0 > -1.596500 && X0 <= 0.815500) && (X1 > -1.192500 && X1 <= 0.030500)) ||
   ((X0 > -1.593500 && X0 <= 0.743500) && (X1 > -1.227500 && X1 <= 0.030500)) ||
   ((X0 > -0.815500 && X0 <= 1.597500) && (X1 > 0.008500 && X1 <= 1.174500)) ||
   ((X0 > -1.115500 && X0 <= -0.141500) && (X1 > -2.000500 && X1 <= 0.875500)) ||
   ((X0 > -1.113500 && X0 <= -0.153500) && (X1 > -2.014500 && X1 <= 0.875500)) ||
   ((X0 > -0.783500 && X0 <= 1.601500) && (X1 > 0.046500 && X1 <= 1.201500)) ||
   ((X0 > 0.175500 && X0 <= 1.074500) && (X1 > -0.898500 && X1 <= 2.029500)) ||
   ((X0 > -0.837500 && X0 <= 1.615500) && (X1 > 0.089500 && X1 <= 1.148500)) ||
   ((X0 > -1.618500 && X0 <= 0.856500) && (X1 > -1.140500 && X1 <= -0.085500)) ||
   ((X0 > -1.073500 && X0 <= -0.201500) && (X1 > -2.035500 && X1 <= 0.888500)) ||
   ((X0 > 0.217500 && X0 <= 1.058500) && (X1 > -0.911500 && X1 <= 2.049500)) ||
   ((X0 > -1.624500 && X0 <= 0.923500) && (X1 > -1.068500 && X1 <= -0.085500)) ||
   ((X0 > 0.217500 && X0 <= 1.033500) && (X1 > -0.942500 && X1 <= 2.049500)) ||
   ((X0 > -0.902500 && X0 <= 1.647500) && (X1 > 0.143500 && X1 <= 1.075500)) ||
   ((X0 > -1.641500 && X0 <= 0.923500) && (X1 > -1.068500 && X1 <= -0.167500)) ||
   ((X0 > -1.012500 && X0 <= -0.274500) && (X1 > -2.061500 && X1 <= 0.978500)) ||
   ((X0 > -0.935500 && X0 <= 1.655500) && (X1 > 0.213500 && X1 <= 1.044500)) ||
   ((X0 > 0.324500 && X0 <= 1.006500) && (X1 > -0.986500 && X1 <= 2.079500)) ||
   ((X0 > -1.666500 && X0 <= 0.946500) && (X1 > -1.036500 && X1 <= -0.262500)) ||
   ((X0 > -0.966500 && X0 <= 1.664500) && (X1 > 0.270500 && X1 <= 1.009500)) ||
   ((X0 > -0.966500 && X0 <= -0.334500) && (X1 > -2.088500 && X1 <= 1.018500)) ||
   ((X0 > -1.675500 && X0 <= 1.019500) && (X1 > -0.973500 && X1 <= -0.330500)) ||
   ((X0 > -1.036500 && X0 <= 1.674500) && (X1 > 0.308500 && X1 <= 0.934500)) ||
   ((X0 > 0.424500 && X0 <= 0.961500) && (X1 > -1.008500 && X1 <= 2.098500)) ||
   ((X0 > -1.065500 && X0 <= 1.690500) && (X1 > 0.384500 && X1 <= 0.907500)) ||
   ((X0 > -1.696500 && X0 <= 1.086500) && (X1 > -0.878500 && X1 <= -0.364500)) ||
   ((X0 > -0.881500 && X0 <= -0.465500) && (X1 > -2.103500 && X1 <= 1.109500)) ||
   ((X0 > 0.502500 && X0 <= 0.895500) && (X1 > -1.096500 && X1 <= 2.107500)) ||
   ((X0 > -1.115500 && X0 <= 1.697500) && (X1 > 0.468500 && X1 <= 0.875500)) ||
   ((X0 > 0.502500 && X0 <= 0.867500) && (X1 > -1.106500 && X1 <= 2.108500)) ||
   ((X0 > -1.151500 && X0 <= 1.717500) && (X1 > 0.497500 && X1 <= 0.811500)) ||
   ((X0 > -1.712500 && X0 <= 1.150500) && (X1 > -0.807500 && X1 <= -0.495500)) ||
   ((X0 > 0.516500 && X0 <= 0.758500) && (X1 > -1.225500 && X1 <= 2.117500)) ||
   ((X0 > -0.783500 && X0 <= -0.571500) && (X1 > -2.115500 && X1 <= 1.201500)) ||
   ((X0 > -1.719500 && X0 <= 1.205500) && (X1 > -0.791500 && X1 <= -0.611500)) ||
   ((X0 > -1.725500 && X0 <= 1.161500) && (X1 > -0.796500 && X1 <= -0.666500)) ) return 0;

  return 1;
}
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
int ApplyRules_LLMzero_meno(float X0, float X1) {
  
	if (   ((X0 > -0.492500 && X0 <= 1.685500) && (X1 > -0.735500 && X1 <= 1.678500)) ||
   ((X0 > -0.386500 && X0 <= 1.678500) && (X1 > -0.735500 && X1 <= 1.815500)) ||
   ((X0 > -0.521500 && X0 <= 1.704500) && (X1 > -0.705500 && X1 <= 1.662500)) ||
   ((X0 > -1.755500 && X0 <= 0.742500) && (X1 > -1.483500 && X1 <= 0.653500)) ||   
   ((X0 > 0.850500 && X0 <= 0.851500) && (X1 > 2.679500 && X1 <= 2.680500)) ) return 0;

  return 1;
}
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
int ApplyRules_LLMzero(float X0, float X1) {
  
	if ( ((X0 > -1.714500 && X0 <= 0.580500) && (X1 > -1.655500 && X1 <= 0.693500)) ||
   ((X0 > -0.694500 && X0 <= 1.770500) && (X1 > -0.644500 && X1 <= 1.499500)) ||
   ((X0 > -0.492500 && X0 <= 1.685500) && (X1 > -0.735500 && X1 <= 1.678500)) ||
   ((X0 > -0.386500 && X0 <= 1.678500) && (X1 > -0.735500 && X1 <= 1.815500)) ||
   ((X0 > -0.521500 && X0 <= 1.704500) && (X1 > -0.705500 && X1 <= 1.662500)) ||
   ((X0 > -1.755500 && X0 <= 0.742500) && (X1 > -1.483500 && X1 <= 0.653500)) ||
   ((X0 > -0.826500 && X0 <= 1.685500) && (X1 > -0.735500 && X1 <= 1.363500)) ||
   ((X0 > -0.647500 && X0 <= 1.749500) && (X1 > -0.644500 && X1 <= 1.535500)) ||
   ((X0 > -0.588500 && X0 <= 1.723500) && (X1 > -0.662500 && X1 <= 1.598500)) ||
   ((X0 > -1.714500 && X0 <= 0.422500) && (X1 > -1.766500 && X1 <= 0.693500)) ||
   ((X0 > -1.798500 && X0 <= 0.742500) && (X1 > -1.442500 && X1 <= 0.625500)) ||
   ((X0 > -0.588500 && X0 <= 1.589500) && (X1 > -0.790500 && X1 <= 1.598500)) ||
   ((X0 > -1.661500 && X0 <= 0.422500) && (X1 > -1.793500 && X1 <= 0.705500)) ||
   ((X0 > -1.760500 && X0 <= 0.631500) && (X1 > -1.547500 && X1 <= 0.625500)) ||
   ((X0 > -1.636500 && X0 <= 0.332500) && (X1 > -1.857500 && X1 <= 0.767500)) ||
   ((X0 > -1.801500 && X0 <= 0.820500) && (X1 > -1.341500 && X1 <= 0.625500)) ||
   ((X0 > -0.760500 && X0 <= 1.824500) && (X1 > -0.587500 && X1 <= 1.409500)) ||
   ((X0 > -1.830500 && X0 <= 0.963500) && (X1 > -1.238500 && X1 <= 0.604500)) ||
   ((X0 > -1.845500 && X0 <= 0.963500) && (X1 > -1.225500 && X1 <= 0.604500)) ||
   ((X0 > -0.342500 && X0 <= 1.589500) && (X1 > -0.790500 && X1 <= 1.867500)) ||
   ((X0 > -1.304500 && X0 <= 1.589500) && (X1 > -0.791500 && X1 <= 0.993500)) ||
   ((X0 > -1.161500 && X0 <= 1.871500) && (X1 > -0.587500 && X1 <= 1.106500)) ||
   ((X0 > -1.599500 && X0 <= 0.212500) && (X1 > -2.001500 && X1 <= 0.767500)) ||
   ((X0 > -1.542500 && X0 <= 0.164500) && (X1 > -2.111500 && X1 <= 0.812500)) ||
   ((X0 > -0.931500 && X0 <= 1.826500) && (X1 > -0.587500 && X1 <= 1.254500)) ||
   ((X0 > -0.228500 && X0 <= 1.582500) && (X1 > -0.790500 && X1 <= 1.996500)) ||
   ((X0 > -1.481500 && X0 <= 0.839500) && (X1 > -1.326500 && X1 <= 0.852500)) ||
   ((X0 > -0.284500 && X0 <= 1.606500) && (X1 > -0.735500 && X1 <= 1.908500)) ||
   ((X0 > -1.039500 && X0 <= 1.861500) && (X1 > -0.587500 && X1 <= 1.141500)) ||
   ((X0 > -1.338500 && X0 <= 1.186500) && (X1 > -1.063500 && X1 <= 0.921500)) ||
   ((X0 > -0.103500 && X0 <= 1.540500) && (X1 > -0.819500 && X1 <= 2.126500)) ||
   ((X0 > -1.285500 && X0 <= 1.907500) && (X1 > -0.509500 && X1 <= 0.997500)) ||
   ((X0 > -1.199500 && X0 <= 0.870500) && (X1 > -1.297500 && X1 <= 1.032500)) ||
   ((X0 > -1.910500 && X0 <= 1.383500) && (X1 > -0.897500 && X1 <= 0.574500)) ||
   ((X0 > -1.481500 && X0 <= 0.043500) && (X1 > -2.208500 && X1 <= 0.852500)) ||
   ((X0 > -0.054500 && X0 <= 1.502500) && (X1 > -0.819500 && X1 <= 2.204500)) ||
   ((X0 > -1.918500 && X0 <= 1.387500) && (X1 > -0.887500 && X1 <= 0.542500)) ||
   ((X0 > -1.582500 && X0 <= 1.923500) && (X1 > -0.509500 && X1 <= 0.812500)) ||
   ((X0 > -0.004500 && X0 <= 1.451000) && (X1 > -0.857500 && X1 <= 2.232500)) ||
   ((X0 > -0.267500 && X0 <= 1.275500) && (X1 > -0.971500 && X1 <= 1.953500)) ||
   ((X0 > -1.459500 && X0 <= -0.066500) && (X1 > -2.301500 && X1 <= 0.852500)) ||
   ((X0 > -1.459500 && X0 <= -0.088500) && (X1 > -2.311500 && X1 <= 0.852500)) ||
   ((X0 > 0.052500 && X0 <= 1.442500) && (X1 > -0.857500 && X1 <= 2.262500)) ||
   ((X0 > -1.021500 && X0 <= 0.332500) && (X1 > -1.863500 && X1 <= 1.197500)) ||
   ((X0 > -1.390500 && X0 <= -0.124500) && (X1 > -2.335500 && X1 <= 0.886000)) ||
   ((X0 > 0.154500 && X0 <= 1.405500) && (X1 > -0.874500 && X1 <= 2.352500)) ||
   ((X0 > -1.886500 && X0 <= 1.954500) && (X1 > -0.420500 && X1 <= 0.604500)) ||
   ((X0 > -1.348500 && X0 <= -0.198500) && (X1 > -2.396500 && X1 <= 0.903500)) ||
   ((X0 > 0.225500 && X0 <= 1.339500) && (X1 > -0.922500 && X1 <= 2.459500)) ||
   ((X0 > -1.995500 && X0 <= 1.723500) && (X1 > -0.645500 && X1 <= 0.312500)) ||
   ((X0 > -1.278500 && X0 <= -0.357500) && (X1 > -2.535500 && X1 <= 0.996500)) ||
   ((X0 > -1.199500 && X0 <= -0.281500) && (X1 > -2.483500 && X1 <= 1.032500)) ||
   ((X0 > 0.358500 && X0 <= 1.275500) && (X1 > -0.971500 && X1 <= 2.500500)) ||
   ((X0 > 0.376500 && X0 <= 1.235500) && (X1 > -1.038500 && X1 <= 2.529500)) ||
   ((X0 > -1.974500 && X0 <= 1.988500) && (X1 > -0.336500 && X1 <= 0.443500)) ||
   ((X0 > -0.521500 && X0 <= 0.275500) && (X1 > -1.940500 && X1 <= 1.661500)) ||
   ((X0 > 0.414500 && X0 <= 1.186500) && (X1 > -1.062500 && X1 <= 2.571500)) ||
   ((X0 > 0.051500 && X0 <= 0.810500) && (X1 > -1.393500 && X1 <= 2.263500)) ||
   ((X0 > 0.488500 && X0 <= 1.226500) && (X1 > -1.038500 && X1 <= 2.622500)) ||
   ((X0 > -0.456500 && X0 <= 0.275500) && (X1 > -1.940500 && X1 <= 1.741500)) ||
   ((X0 > -1.187500 && X0 <= -0.478500) && (X1 > -2.591500 && X1 <= 1.032500)) ||
   ((X0 > -2.010500 && X0 <= 1.953500) && (X1 > -0.405500 && X1 <= 0.228500)) ||
   ((X0 > -1.088500 && X0 <= -0.478500) && (X1 > -2.632500 && X1 <= 1.125500)) ||
   ((X0 > -1.120500 && X0 <= -0.508500) && (X1 > -2.639500 && X1 <= 1.102500)) ||
   ((X0 > 0.583500 && X0 <= 1.068500) && (X1 > -1.115500 && X1 <= 2.630500)) ||
   ((X0 > -0.140500 && X0 <= 0.332500) && (X1 > -1.854500 && X1 <= 2.052500)) ||
   ((X0 > 0.631500 && X0 <= 1.043500) && (X1 > -1.192500 && X1 <= 2.663500)) ||
   ((X0 > -0.695500 && X0 <= -0.427500) && (X1 > -2.559500 && X1 <= 1.519500)) ||
   ((X0 > -0.925500 && X0 <= -0.641500) && (X1 > -2.671500 && X1 <= 1.311500)) ||
   ((X0 > 0.488500 && X0 <= 0.681500) && (X1 > -1.493500 && X1 <= 2.625500)) ||
   ((X0 > 0.455500 && X0 <= 0.458500)) ||
   ((X0 > 0.855500 && X0 <= 0.856500)) ||
   ((X1 > -0.752500 && X1 <= -0.751500)) ||
   ((X0 > 0.864500 && X0 <= 0.866500)) ||
   ((X1 > -0.697500 && X1 <= -0.696500)) ||
   ((X1 > 0.205500 && X1 <= 0.206500)) ||
   ((X0 > -1.930500 && X0 <= -1.929500) && (X1 > -0.762500 && X1 <= -0.761500)) ||
   ((X0 > 0.850500 && X0 <= 0.851500) && (X1 > 2.679500 && X1 <= 2.680500)) ) return 0;

  return 1;
}
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
int ApplyRules(float X0, float X1) {
  
	// 24% unstable, ripeto con LLM 0% errore...
	//if ( ((X0 > -1.806500 && X0 <= 1.996500) && (X1 > -1.090500 && X1 <= 2.248500)) || 
		//((X0 > -2.013500 && X0 <= 0.992500) && (X1 > -2.674500 && X1 <= 0.559500)) ) return 0;

	// ... e value ranking su unstable: 15% unstable, da cui stavolta prendo le prime 6 regole stable...
	//if ((X0 > -1.78 && X0 < 1.73) && (X1 > -2.0 && X1 < 1.57)) return 0;

	// 	0.066% unstable (1534 campioni di safe+uscitoROA+1 unsafe), secondo prova più lunga (10335): 0.019% unstable 9% uscito ROA
    // dovrei vedere se, usando tutte le regole stable, si può allargare la ROA come dice V per coprire a zero l'uscito dalla ROA 
	if ( ((X0 > -1.491000 && X0 <= 0.752500) && (X1 > -1.350500 && X1 <= 0.809500)) ||
  ((X0 > -1.605500 && X0 <= 1.006000) && (X1 > -1.127000 && X1 <= 0.671500)) ||
  ((X0 > -1.379500 && X0 <= 0.506500) && (X1 > -1.627500 && X1 <= 0.852500)) ||
  ((X0 > -1.447500 && X0 <= 0.618500) && (X1 > -1.448500 && X1 <= 0.809500)) ||
  ((X0 > -1.542000 && X0 <= 0.850500) && (X1 > -1.253500 && X1 <= 0.671500)) ||
  ((X0 > -1.213500 && X0 <= 1.245500) && (X1 > -0.904500 && X1 <= 1.010500)) ||
  ((X0 > -1.033500 && X0 <= 0.981500) && (X1 > -1.130000 && X1 <= 1.166000)) ) return 0;

	// ... prendo le soglie più stringenti da sopra (raddoppio il # campioni e ne uso 1e5):
	// stable, 11% uscito dalla ROA, confermato in una 2nda prova
	//if ((X0 > -1.033500 && X0 < 0.506500) && (X1 > -0.904500 && X1 < 0.671500)) return 0;

	// oppure quelle più ampie: 5.8% di unstable
	//if ((X0 > -1.605500 && X0 <= 1.245500) && (X1 > -1.627500 && X1 <= 1.166000)) return 0;

  return 1;
}
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
double Funzione_InseguiFunzione(double x){

	return sin(x);
}
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
void Addestra_InseguiFunzione(){
	
	int i,k;
	double inc;
	int conta=0;
	double Ingresso[1];
	double InitDelta[1];

	EseguiTest_InseguiFunzione(NULL);

	for(k=0; k<=(int)1e5*3; k++){
	
		conta++;
		inc=-(pigreco_inc);
		
		for(i=0; i<=campionifunzione; i++){
			
			inc += pigreco_inc;
			Ingresso[0]=inc;

			NN_funzione->CalcolaUscitaReteNeurale(Ingresso);

			InitDelta[0]=2*(NN_funzione->Gety_2(0) - Funzione_InseguiFunzione(Ingresso[0]));

			NN_funzione->AddestraReteNeurale(k,InitDelta);

		}

		if(conta==1e5){
			conta=0;
			EseguiTest_InseguiFunzione(NULL);
		}

	}//end ciclo addestramento su k

}
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
double EseguiTest_InseguiFunzione(double *x, bool stampa){

	double inc=-(pigreco_inc);
	double res=0.0;
	int i;
	double Ingresso[1];
	 int p,q,indice=-1;

	 if(x != NULL){

		 //////////////////////// aggiorno i pesi ////////////////////////
	   for(p=1;p<=NN_funzione->n_0;p++)
			for(q=1;q<=NN_funzione->n_1;q++){
				indice++;
				NN_funzione->w_1[p-1][q-1]=x[indice];
			}
		for(q=1;q<=NN_funzione->n_1;q++){
			indice++;
			NN_funzione->w0_1[q-1]=x[indice];
		}
		
		for(p=1;p<=NN_funzione->n_1;p++)
			for(q=1;q<=NN_funzione->n_2;q++){
				indice++;
				NN_funzione->w_2[p-1][q-1]=x[indice];
			}
		for(q=1;q<=NN_funzione->n_2;q++){
			indice++;
			NN_funzione->w0_2[q-1]=x[indice];
		}
	   //////////////////////// END aggiorno i pesi ////////////////////////

	/*
		///////////// stampa reti reurale /////////////
	   printf("\n\n-----NN_funzione-----");
	   NN_funzione->StampaTuttiIPesiReteNeurale();
	   ///////////// END stampa reti reurali /////////////

		///////////// stampa x /////////////
		printf("\n\n-----x (in EseguiTest_InseguiFunzione) -----");
		for(i=0;i< ( (NN_funzione->n_0*NN_funzione->n_1)+(NN_funzione->n_1*NN_funzione->n_2)+NN_funzione->n_1+NN_funzione->n_2 ); i++)
			printf("\nx[%d]=%lf",i,x[i]);
		///////////// END stampa x ///////////// 	
		printf("\n\n"); system("pause");
	*/

		if(stampa) printf("\n\n");
		for(i=0; i<=campionifunzione; i++){

			inc += pigreco_inc;
			Ingresso[0]=inc;

			NN_funzione->CalcolaUscitaReteNeurale(Ingresso);

			res += pow( NN_funzione->Gety_2(0)-Funzione_InseguiFunzione(inc) ,2);

			if(stampa) printf("\n%f\t%f\t%f",inc,Funzione_InseguiFunzione(Ingresso[0]),NN_funzione->Gety_2(0));
		}
		if(stampa) printf("\t\tCosto=%f",res);
		//system("pause");

	 }//END if(x != NULL)
	 else{

		printf("\n\n");
		for(i=0; i<=campionifunzione; i++){

			inc += pigreco_inc;
			Ingresso[0]=inc;

			NN_funzione->CalcolaUscitaReteNeurale(Ingresso);
			res += pow( NN_funzione->Gety_2(0)-Funzione_InseguiFunzione(Ingresso[0]) ,2);

			printf("\n%f\t%f\t%f",inc,Funzione_InseguiFunzione(Ingresso[0]),NN_funzione->Gety_2(0));
		}

		printf("\t\tCosto=%f",res);

	 }

	 //printf("\n%e",res);
	 //system("pause");

	return res;

}
////////////////////////////////////////////////////////////////////

double f1(double *X){

	return (-X[1]);
}
double f2(double *X){

	return (X[0]+(pow(X[0],2)-1)*X[1]);
}

double f3(double *X){

	return (X[0]*X[3]-X[2]);
}
double f4(double *X){

	return (X[0]*X[2]-pow(X[3],3));
}

double V(double *X){

	c[0]=1.5; c[1]=-1; c[2]=1;
	double res=c[0]*pow(X[0],2)+c[1]*X[0]*X[1]+c[2]*pow(X[1],2);	

	return res;
}

double deVsudex1(double *X){

	double res;	

	res=c[0]*X[1]*pow(X[2],2)+c[1]*X[1]+c[2]*pow(X[1],3)+
		c[3]*X[1]*pow(X[3],2)+c[4]*0+c[5]*2*X[0]+c[6]*0+
		c[7]*0+c[8]*0+c[9]*2*X[0]*pow(X[1],2)+c[10]*0+
		c[11]*3*pow(X[0],2)*X[1]+c[12]*4*pow(X[0],3)+c[13]*0+c[14]*2*X[0]*pow(X[2],2)+
		c[15]*0+c[16]*2*X[0]*pow(X[3],2)+c[17]*0+
		c[18]*0+c[19]*X[3]*X[2]+c[20]*0;

	return res;
}

double deVsudex2(double *X){

	double res;	

	res=c[0]*X[0]*pow(X[2],2)+c[1]*X[0]+c[2]*3*pow(X[1],2)*X[0]+
		c[3]*X[0]*pow(X[3],2)+c[4]*0+c[5]*0+c[6]*0+
		c[7]*2*X[1]+c[8]*0+c[9]*2*X[1]*pow(X[0],2)+c[10]*0+
		c[11]*pow(X[0],3)+c[12]*0+c[13]*4*pow(X[1],3)+c[14]*0+
		c[15]*2*X[1]*pow(X[2],2)+c[16]*0+c[17]*2*X[1]*pow(X[3],2)+
		c[18]*0+c[19]*0+c[20]*X[3]*X[2];

	return res;
}

double deVsudex3(double *X){

	double res;	

	res=c[0]*X[0]*X[1]*2*X[2]+c[1]*0+c[2]*0+
		c[3]*0+c[4]*0+c[5]*0+c[6]*2*X[2]+
		c[7]*0+c[8]*0+c[9]*0+c[10]*4*pow(X[2],3)+
		c[11]*0+c[12]*0+c[13]*0+c[14]*pow(X[0],2)*2*X[2]+
		c[15]*pow(X[1],2)*2*X[2]+c[16]*0+c[17]*0+
		c[18]*pow(X[3],2)*2*X[2]+c[19]*X[0]*X[3]+c[20]*X[1]*X[3];

	return res;
}

double deVsudex4(double *X){

	double res;	

	res=c[0]*0+c[1]*0+c[2]*0+
		c[3]*X[0]*X[1]*2*X[3]+c[4]*4*pow(X[3],3)+c[5]*0+c[6]*0+
		c[7]*0+c[8]*2*X[3]+c[9]*0+c[10]*0+
		c[11]*0+c[12]*0+c[13]*0+c[14]*0+
		c[15]*0+c[16]*pow(X[0],2)*2*X[3]+c[17]*pow(X[1],2)*2*X[3]+
		c[18]*pow(X[2],2)*2*X[3]+c[19]*X[0]*X[2]+c[20]*X[1]*X[2];

	return res;
}

double Vpunto(double *X){

	double res; 
	
	res=-(pow(X[0],2)+pow(X[1],2)) - (pow(X[0],3)*X[1]-2*pow(X[0],2)*pow(X[1],2));

	return res;
}

////////////////////////////////////////////////////////////////////
void Liapunov1(){

	int nparam,nf,nineq,neq,mode,iprint,miter,neqn,nineqn,
       ncsrl,ncsrn,nfsr,mesh_pts[1],inform,i;
   double bigbnd,eps,epsneq,udelta;
   double *x,*bl,*bu,*f,*g,*lambda;
   void *cd;

   mode=100;//100
   iprint=2;
   miter=500;  //500
   bigbnd=1.e10;
   eps=1.e-8;
   epsneq=0.e0;
   udelta=1e-2;//1e-8;//0.e0

   nparam=numc;
	
   nf=1;
   neqn=0;
   nineqn=0;
   nineq=0;
   neq=0;
   ncsrl=ncsrn=nfsr=mesh_pts[0]=0;
   bl=(double *)calloc(nparam,sizeof(double));
   bu=(double *)calloc(nparam,sizeof(double));
   x=(double *)calloc(nparam,sizeof(double));
   f=(double *)calloc(nf,sizeof(double));
   g=(double *)calloc(nineq+neq,sizeof(double));
   lambda=(double *)calloc(nineq+neq+nf+nparam,sizeof(double));
   
   for(i=0;i<nparam;i++){
	   x[i]=NumeroRand(1);
	   //x[0]=1/2.8; x[1]=1/1.9; 
	   //x[0]=5; x[1]=5; 
	   bl[i]= -2;
	   bu[i]= 2;
   }   

   cfsqp(nparam,nf,nfsr,nineqn,nineq,neqn,neq,ncsrl,ncsrn,mesh_pts,
         mode,iprint,miter,&inform,bigbnd,eps,epsneq,udelta,bl,bu,x,
         f,g,lambda,obj32_bis,cntr32_bis,grobfd,grcnfd,cd=NULL);//grob32 al posto di grobfd e grcn32 al posto di grcnfd per passare i gradienti 
   //system("pause");

   free(bl);
   free(bu);
   //free(x);
   free(f);
   free(g);
   free(lambda);
   //return 0;
}
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
void AddestraNN_funzioneconCFSQP(){

	int nparam,nf,nineq,neq,mode,iprint,miter,neqn,nineqn,
       ncsrl,ncsrn,nfsr,mesh_pts[1],inform,i;//,p,q;
   double bigbnd,eps,epsneq,udelta;
   double *x,*bl,*bu,*f,*g,*lambda;
   void *cd;

   mode=100;//100
   iprint=1;
   miter=500;  //500
   bigbnd=1.e10;
   eps=1.e-8;
   epsneq=0.e0;
   udelta=1e-8;//0.e0
//---------------------------------------------------
	//con le reti neurali
	nparam=0;
	nparam += (NN_funzione->n_0*NN_funzione->n_1)+(NN_funzione->n_1*NN_funzione->n_2)+NN_funzione->n_1+NN_funzione->n_2;
//---------------------------------------------------
   nf=1;
   neqn=0;
   nineqn=0;
   nineq=0;
   neq=0;
   ncsrl=ncsrn=nfsr=mesh_pts[0]=0;
   bl=(double *)calloc(nparam,sizeof(double));
   bu=(double *)calloc(nparam,sizeof(double));
   x=(double *)calloc(nparam,sizeof(double));
   f=(double *)calloc(nf,sizeof(double));
   g=(double *)calloc(nineq+neq,sizeof(double));
   lambda=(double *)calloc(nineq+neq+nf+nparam,sizeof(double));

//----------------------------------- initi di x e stampa di controllo che x sia settato bene -----------------------------------  
/*
   int indice=-1;
   
   ////////////////////////////////////////////////
   for(p=1;p<=NN_funzione->n_0;p++)
		for(q=1;q<=NN_funzione->n_1;q++){
			indice++;
			x[indice]=NN_funzione->w_1[p-1][q-1];
		}
	for(q=1;q<=NN_funzione->n_1;q++){
		indice++;
		x[indice]=NN_funzione->w0_1[q-1];
	}
	
	for(p=1;p<=NN_funzione->n_1;p++)
		for(q=1;q<=NN_funzione->n_2;q++){
			indice++;
			x[indice]=NN_funzione->w_2[p-1][q-1];
		}
	for(q=1;q<=NN_funzione->n_2;q++){
		indice++;
		x[indice]=NN_funzione->w0_2[q-1];
	}
   ////////////////////////////////////////////////

   for(i=0;i<nparam;i++)
		x[i] += NumeroRand(0.1);

   indice=-1;
   
   ////////////////////////////////////////////////
   for(p=1;p<=NN_funzione->n_0;p++)
		for(q=1;q<=NN_funzione->n_1;q++){
			indice++;
			NN_funzione->w_1[p-1][q-1]=x[indice];
		}
	for(q=1;q<=NN_funzione->n_1;q++){
		indice++;
		NN_funzione->w0_1[q-1]=x[indice];
	}
	
	for(p=1;p<=NN_funzione->n_1;p++)
		for(q=1;q<=NN_funzione->n_2;q++){
			indice++;
			NN_funzione->w_2[p-1][q-1]=x[indice];
		}
	for(q=1;q<=NN_funzione->n_2;q++){
		indice++;
		NN_funzione->w0_2[q-1]=x[indice];
	}
   ////////////////////////////////////////////////

   ///////////// stampa reti reurale /////////////
   printf("\n\n-----NN_funzione-----");
   NN_funzione->StampaTuttiIPesiReteNeurale();
   ///////////// END stampa reti reurali /////////////

    ///////////// stampa x /////////////
	printf("\n\n-----x-----");
	for(i=0;i<nparam;i++)
		printf("\nx[%d]=%lf",i,x[i]);
	///////////// END stampa x /////////////

   printf("\n\n\n");exit(0);
   */
//----------------------------------- initi di x e stampa di controllo che x sia settato bene -----------------------------------
   
   for(i=0;i<nparam;i++){
	   x[i]=NumeroRand(1.0);
	   bl[i]= -10.0;
	   bu[i]= 10.0;
   }
   /*printf("\n\n");
   for(i=0;i<nparam;i++)
		printf("\nbl[%d]=%e",i,bl[i]);
   printf("\n");
   for(i=0;i<nparam;i++)
		printf("\nbu[%d]=%e",i,bu[i]);
   printf("\n\n");*/

   EseguiTest_InseguiFunzione(NULL);
   //NN_funzione->StampaTuttiIPesiReteNeurale();

   cfsqp(nparam,nf,nfsr,nineqn,nineq,neqn,neq,ncsrl,ncsrn,mesh_pts,
         mode,iprint,miter,&inform,bigbnd,eps,epsneq,udelta,bl,bu,x,
         f,g,lambda,obj32,cntr32,grobfd,grcnfd,cd=NULL);//grob32 al posto di grobfd e grcn32 al posto di grcnfd per passare i gradienti 
   //system("pause");

   EseguiTest_InseguiFunzione(NULL);    
   //NN_funzione->StampaTuttiIPesiReteNeurale();

   free(bl);
   free(bu);
   //free(x);
   free(f);
   free(g);
   free(lambda);
   //return 0;
}
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
void ROA_bruteforce()
{

	int i,jj,ii,jjj, classe; double res=0, penality=0; 
	// eq. di stato con X
	double *X; 
	// griglia
	double granularita=50, inc=4/granularita, xmin=-3;
	FILE *Output2; Output2=fopen("ROA.txt","w"); fclose(Output2);
	//Output2=fopen("ROA_bruteforce.txt","w"); fprintf(Output2,"X0\tX1\tclasse"); fclose(Output2);

	X=(double *)calloc(2,sizeof(double));	
	
	for(i=0;i<(granularita+inc)*1.5;i++){ 		
		X[0]=xmin+i*inc;
		for(jj=0;jj<(granularita+inc)*1.5;jj++){			
			X[1]=xmin+jj*inc;
			
			classe=Srotola(X[0],X[1]);	

			//classe=ApplyRules_sogliaVR(X[0],X[1]);

			//if(V(X)<3.736222) classe=0; else classe=1;

			// singola regola
			//if(((X[0] > -1.514500 && X[0] <= 0.480500) && (X[1] > -1.455500 && X[1] <= 0.63500))==0) classe=0; else classe=1;
			
			//if(ApplyRules_LLMzero_meno(X[0],X[1])==0) classe=0; else classe=1;
						
			//if(ApplyRules_LLMzero(X[0],X[1])==0) classe=0; else classe=1;
			//if(ApplyRules_DT(X[0],X[1])==0) classe=0; else classe=1;
			
			Output2=fopen("ROA.txt","a"); 
			fprintf(Output2,"\n%.3f\t%.3f",X[0],X[1]); 
			fprintf(Output2,"\t%d",classe); 
			fclose(Output2);
		}
	}	

	/*
I=load('ROA.txt'); gscatter(I(:,1),I(:,2),I(:,3),'br'); hold on;
I=load('ROA.txt'); gscatter(I(:,1),I(:,2),I(:,3),'gw','..');

https://www.mathworks.com/help/stats/gscatter.html
	*/
		   
}
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
int Srotola(double x0, double x1){

	double stepsize=0.01, tempo, DurataSrotola=100; bool exit; int out;
	double *X;
	X=(double *)calloc(2,sizeof(double));	
	X[0]=x0; X[1]=x1;

	tempo=0; exit=false;
	while( tempo<=DurataSrotola && !exit){

		tempo+=stepsize;
		X[0]=X[0] + stepsize*f1(X); X[1]=X[1] + stepsize*f2(X); 
		if(modulo(X[0])>1e4 || modulo(X[1])>1e4) 
			exit=true;		
		 				
	}//END while(clock<=DurataSrotola)			

  if(X[0]<0.1 && X[1]<0.1) out=0; else out=1;

  return out;
}
////////////////////////////////////////////////////////////////////


void obj32_bis(int nparam, int j, double *x,double *fj, void *cd)
{

	int i,jj,ii,jjj; double res=0, penality=0; 
	// eq. di stato con X
	double *X; 
	// griglia
	double granularita=50, inc=4/granularita, xmin=-2;

	X=(double *)calloc(4,sizeof(double));

	for(i=0;i<numc;i++)
		c[i]=x[i];
	
	for(i=0;i<granularita+inc;i++){ 		
		X[0]=xmin+i*inc;
		for(jj=0;jj<granularita+inc;jj++){			
			X[1]=xmin+jj*inc;
			for(ii=0;ii<granularita+inc;ii++){
				X[2]=xmin+ii*inc;
				for(jjj=0;jjj<granularita+inc;jjj++){
					X[3]=xmin+jjj*inc;
					if(V(X)<0) penality+=1;
				}
			}			
		}
	}
	res+=penality; 

	for(i=0;i<granularita+inc;i++){ 		
		X[0]=xmin+i*inc;
		for(jj=0;jj<granularita+inc;jj++){			
			X[1]=xmin+jj*inc;
			for(ii=0;ii<granularita+inc;ii++){
				X[2]=xmin+ii*inc;
				for(jjj=0;jjj<granularita+inc;jjj++){
					X[3]=xmin+jjj*inc;
					if(Vpunto(X)>0) penality+=1;
				}
			}			
		}
	}
	res+=penality; 
	// if(Vpunto(x,X)>0) penality+=1;
	//penality+=sqrt(pow(X[0],2)+pow(X[1],2))/sqrt(pow(modulo(xmin),2)+pow(modulo(xmin),2));

	*fj=res;	

	free(X);
		
   return;
}

void cntr32_bis(int nparam,int j,double *x,double *gj,void *cd)
{

	return;
}


//////////////////////////////////////// --- costo e vincoli con Montecarlo --- ////////////////////////////////////////

void obj32(int nparam, int j, double *x,double *fj, void *cd)
{
	
	double res=0.0;

	///////////// stampa x /////////////
	/*printf("\n\n-----x (in obj32) -----");
	for(i=0;i< ( (NN_funzione->n_0*NN_funzione->n_1)+(NN_funzione->n_1*NN_funzione->n_2)+NN_funzione->n_1+NN_funzione->n_2 ); i++)
		printf("\nx[%d]=%lf",i,x[i]);*/
	///////////// END stampa x ///////////// 

	 res= EseguiTest_InseguiFunzione(x); 

	 //res -= 0.5;
   
   *fj=res;
   return;
}

void cntr32(int nparam,int j,double *x,double *gj,void *cd)
{

	return;
	
	double res=0.0;

	 res= EseguiTest_InseguiFunzione(x); 

	 res -= 0.5;

	//res -= distorsione_ref;

   *gj=res;

   return;
}


////////////////////////////////////////////////////////////////////
double NumeroRand(double max){

	double out;
	
	double NumeroRand0ToRandMax=rand();
	out=NumeroRand0ToRandMax/RAND_MAX;
	out=out*max;

	return out;
}
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
double TrovaMinimo(double *Array, int MaxDim){

double minimo=1000000000000.0;
for(int i=0;i<MaxDim;i++)
        if(Array[i]<minimo)
                minimo=Array[i];
return minimo;
}
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
double modulo(double num){

	if(num<0)
		return (-num);
	else
		return num;
}
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
double TrovaMassimo(double *Array, int MaxDim){

double Max=-1000000000000.0;
for(int i=0;i<MaxDim;i++)
        if(Array[i]>Max)
                Max=Array[i];
return Max;
}
////////////////////////////////////////////////////////////////////